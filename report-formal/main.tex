\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb, amsfonts}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{appendix}
\usepackage{algorithm,algpseudocode}
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage{caption}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% Margins
\usepackage[top=2.5cm, left=3cm, right=3cm, bottom=3.0cm]{geometry}
% Colour table cells
\usepackage[table]{xcolor}

% header package
\usepackage[nocheck]{fancyhdr}

% Get larger line spacing in table
\newcommand{\tablespace}{\\[1.25mm]}
\newcommand\Tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\tstrut{\rule{0pt}{2.0ex}}         % = `top' strut
\newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



%%%%%%%%%%%%%%%%%
%     Title     %
%%%%%%%%%%%%%%%%%
\title{\textbf{ Graduation Project Report }}
\author{Spring 2024 \\ \\ Hanheng He (400485161) \\ \\ Project Instructor: Dr. Antoine Deza }
\date{April 10, 2024}


\begin{document}
\maketitle

\pagestyle{fancy}
\fancyhead[L]{\text{Graduation Project Report}}
\fancyhead[R]{\text{HH}}

%%%%%%%%%%%%%%%%
%   Abstract   %
%%%%%%%%%%%%%%%%
\begin{abstract}
    This report describe the condition number of a matrix, and an equivalent quantities to the condition number when entries of matrix is specified as $\{0, 1\}$ or $\{-1, 1\}$. Base on this, the implementation of creating an $\{0, 1\}$ matrix is demonstrated, and the equivalent condition number is provided, showing that such kind of $\{0, 1\}$ matrix becomes more ill-conditioned when it's order grows. Further more, this report discusss the complexity of creating such matrix, proving and showing with an experiment of the exponential time complexity.
\end{abstract}
\tableofcontents



\pagebreak
%%%%%%%%%%%%%%%%%
%   1 Introduction
%%%%%%%%%%%%%%%%%
\section{Introduction}

Let matrix $A \in \mathbb{R}^{n\times n}$ be an invertible matrix, with the $spectral \ norm$ defined as $||A||_s = sup_{x\neq0}|Ax|/|x|$, the $condition\ number$ of $A$ is $c(A) = ||A||_s||A^{-1}||_s$. The $condition\ number$ is a measurement of the sensibility of the equation $Ax = b$ when right hand side is changed \cite{ALON1997133}. If $c(A)$ is large, then $A$ is called $ill-conditioned$.

With such an importance property of $condition\ number$, ill-conditioned matrices are important
in numerical algebra, and have been studied extensively by various researchers, such as \cite{doi:10.1137/1018113}, \cite{wilkinson1972note} and \cite{neumaier1998solving}. In \cite{GRAHAM1984113}, researchers restricted entries into set $\{0, 1\}$ or $\{-1, 1\}$, denoted by $\mathcal{A}_n^1$ or $\mathcal{A}_n^2$, which they call $anti-Hadamard$ matrices, with is of interest in linear algebra, objects in combinatorics and related areas. With such conditions, many quantities are equivalent to the condition number. Let $A$ be a non-singular $(0, 1)$ matrix, $B = A^{-1} = (b_{ij})$, the following quantity as an equivalent condition number is considered in \cite{GRAHAM1984113}:
\begin{align*}
\chi(A) = max_{i, j}|b_{ij}|\ and\ \chi(n) = max_A \chi(A),
\end{align*}
which is bounded controlled by $n$ and some absolute positive constant $c$. Meanwhile, since matrix $A$ only contains $0$ and $1$, it also stands for a 0/1-polytope space, which is of great interest in geometry.

In this report, we aim to construct an ill-conditioned $(0, 1)$ matrix $C$ satisfied
\begin{align*}
\chi(C) \geq2^{\frac{1}{2}n\log n-n(2+o(1))}.
\end{align*}
That is said, matrix $C$ has a controlled lower bound of it's $condition\ number$ with respect to $n$. 

As is shown in \cite{ALON1997133}, we started from generating matrix $A \in \mathcal{A}_n^2$, and we generate $B \in \mathcal{A}_n^1$ based on $A$. Using a series of matrix $B$ with different shapes, we can further concatenate a matrix $C$ with it's condition number controlled.



%%%%%%%%%%%%%%%%%
%   2 Generate Ill-conditioned Matrix $C$
%%%%%%%%%%%%%%%%%
\section{Generate Ill-conditioned Matrix $C$}


%%%%%%%%%%%%%%%%%
%   2.1 Generate Set $\Omega$
%%%%%%%%%%%%%%%%%
\subsection{Generate Set $\Omega$}
To start constructing matrix $C$ with a controlled $condition\ number$, the set $\Omega$ with special restriction is necessary. Let $|\cdot|$ denotes cardinality and $\Delta$ denote symmetric different. Let $m\in \mathbb{Z}^{+}$, $n=2^m$, set $\Omega = \{\alpha_0, \alpha_1, \alpha_2, ..., \alpha_n\}$ with $n + 1$ elements is required to create with a restriction that $|\alpha_i| \leq |\alpha_{i+1}|$ and $|\alpha_i \Delta \alpha_{i+1}| \leq 2$. Shown in \cite{doi:10.1137/S0895480192235878}, $\Omega$ is proved to be existed, the only thing considering is the implementational way create such kind of set. The following description shows and implemented way.

Let $\alpha_0=\{\varnothing\}$. We also have $\alpha_1=\{\varnothing\}$. Suppose we have $\Omega = \{\{\varnothing\}, \{\varnothing\}, \{1\}, \{2\}, ..., \{m\}\}$ initially. Conidering for every time we only take out all the sets with maximum size in $\Omega$, and insert only one element inside by order. That is, for an existed set $\{1\}$, we insert element one by one $2, 3, ..., m$ by order.

With this way of insertion, we only need to consider if the conditions are met between the last old set and the first new set, and the continuous new sets come from different old sets. For all the sets come from the same old set, the conditions are automatically met.
\begin{lstlisting}
Initially Omega = {{}, {}, {1}, {2}, ..., {m}}, take {1}, {2}, ..., {m} out, 
and insert only one element each time. Make sure conditions are met between
    1. {m} and {1, _}; 
    2. {1, _} and {2, _}, {2, _} and {3, _}, ...
\end{lstlisting}

For the first case above, the only element we can insert is $m$, which is the first element if we revert the ordered insertion. For the second case, let's say we have set $\alpha$ with size $k$ and $\beta$ with size $k-1$, if $\alpha \cup \beta = \alpha$, we can insert any element we wish; if $\alpha \cup \beta \neq \alpha$, we can only insert an element $r \in \alpha$. Since we always insert element in order or in reversed order, if the first element of the insertion list is not in $\alpha$, the last element of the insertion list, or the first element of the reverted list must be in $\alpha$.

The following pseudo code shows the way generating $\Omega$: 

\begin{algorithm}[H] 
    \caption{Generate $\Omega$}
    \label{alg:loop}
    \begin{algorithmic}[1]
    \Require{$m$} 
    \Ensure{$\Omega$}
      \State {$\Omega$ $\gets$ $\{\{\}, \{\}, \{1\}, \{2\}, ..., \{m\}\}$}
        \For{$i \gets 1$ to $m-1$}          
            \State {$\Phi$ $\gets$ $sets\ in\ \Omega\ with\ size\ equals\ i$}          
            \For{$\phi$ in $\Phi$}     
                \State {$\alpha$ $\gets$ [max($\phi$) + 1, ..., m]}
                \If{$\alpha$ not in $\Omega$[-1]}:
                    \State {$\alpha$ $\gets$ $\alpha$.reverse()}
                \EndIf
                \For{$a$ in $\alpha$}     
                    \State {$\Omega$ $\gets$ \{$\Omega$..., \{$\phi$..., $a$\}\}} \Comment{$\phi...$ means extend set $\phi$}
                \EndFor
            \EndFor
        \EndFor
        \State \Return {$\Omega$}
    \end{algorithmic}
\end{algorithm}

when $m=4$, set $\Omega$ is shown below:
\begin{lstlisting}
Omega = {set(), set(), {1}, {2}, {3}, {4}, 
        {1, 4}, {1, 3}, {1, 2}, {2, 4}, {2, 3}, 
        {3, 4}, {1, 3, 4}, {1, 2, 3}, {1, 2, 4}, 
        {2, 3, 4}, {1, 2, 3, 4}}
\end{lstlisting}


%%%%%%%%%%%%%%%%%
%   2.2 Generate Matrix $A \in \mathcal{A}_n^2$
%%%%%%%%%%%%%%%%%
\subsection{Construct Matrix $A \in \mathcal{A}_n^2$ with Set $\Omega$}
Shown in \cite{ALON1997133}, with set $\Omega = \{\alpha_0, \alpha_1, \alpha_2, ..., \alpha_n\}$ satisfies $|\alpha_i| \leq |\alpha_{i+1}|$ and $|\alpha_i \Delta \alpha_{i+1}| \leq 2$, matrix $A$ can be constructed as follows such that $\chi(A)=2^{\frac{1}{2}n\log n-n(1+o(1))}$:\\
For every $1 \leq i,j \leq n$:
\begin{align*}
    a_{ij} = 
    \begin{cases}
    -1,\;\alpha_j\bigcap(\alpha_{i-1}\bigcup\alpha_i)=\alpha_{i-1}\Delta\alpha_{i}\;and\;|\alpha_{i-1}\Delta\alpha_{i}|=2 \\
    (-1)^{|\alpha_{i-1}\bigcap\alpha_j| + 1},\;\alpha_{j}\bigcap(\alpha_{i-1}\bigcup\alpha_{i})\neq\varnothing\;but\;does\;not\;meet\;the\;condition\;above \\
    1,\;\alpha_j\bigcap(\alpha_{i-1}\bigcup\alpha_i)=\varnothing \\
    \end{cases}.
\end{align*}

With the $\Omega$ shown in section 2.1, matrix $A \in \mathcal{A}_n^2$ constructed is shown below:

$$A = 
\left[\begin{smallmatrix}
    1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
    1 & -1 & 1  & 1  & 1  & -1 & -1 & -1 & 1  & 1  & 1  & -1 & -1 & -1 & 1  & -1 \\
    1 & 1  & -1 & 1  & 1  & 1  & 1  & -1 & -1 & -1 & 1  & 1  & -1 & -1 & -1 & -1 \\
    1 & 1  & 1  & -1 & 1  & 1  & -1 & 1  & 1  & -1 & -1 & -1 & -1 & 1  & -1 & -1 \\
    1 & 1  & 1  & 1  & -1 & -1 & 1  & 1  & -1 & 1  & -1 & -1 & 1  & -1 & -1 & -1 \\
    1 & -1 & 1  & 1  & 1  & 1  & -1 & -1 & 1  & 1  & 1  & 1  & -1 & 1  & 1  & 1  \\
    1 & 1  & 1  & -1 & 1  & -1 & 1  & 1  & 1  & -1 & -1 & -1 & 1  & -1 & -1 & -1 \\
    1 & 1  & -1 & 1  & 1  & 1  & -1 & 1  & -1 & -1 & 1  & -1 & -1 & 1  & -1 & -1 \\
    1 & 1  & 1  & 1  & -1 & -1 & 1  & -1 & 1  & 1  & -1 & -1 & -1 & -1 & 1  & -1 \\
    1 & 1  & 1  & -1 & 1  & 1  & -1 & 1  & -1 & 1  & -1 & -1 & 1  & -1 & -1 & -1 \\
    1 & 1  & 1  & 1  & -1 & -1 & 1  & 1  & -1 & -1 & 1  & 1  & -1 & -1 & -1 & -1 \\
    1 & -1 & 1  & 1  & 1  & 1  & 1  & -1 & 1  & 1  & -1 & -1 & 1  & 1  & -1 & -1 \\
    1 & 1  & -1 & 1  & 1  & -1 & -1 & 1  & -1 & 1  & -1 & 1  & -1 & -1 & -1 & 1  \\
    1 & 1  & 1  & 1  & -1 & 1  & -1 & -1 & 1  & -1 & -1 & -1 & 1  & -1 & -1 & 1  \\
    1 & 1  & 1  & -1 & 1  & -1 & -1 & -1 & -1 & 1  & 1  & -1 & -1 & 1  & -1 & 1  \\
    1 & -1 & 1  & 1  & 1  & 1  & 1  & 1  & -1 & -1 & -1 & -1 & -1 & -1 & 1  & 1  \\
\end{smallmatrix}\right].
$$

In \cite{ALON1997133}, researchers further discussed some properties of the $\{-1, 1\}$ matrix. Let symmetric Hadamard matrix $Q$ be an $n$ by $n$ matrix given by $q_{ij} = (-1)^{|\alpha_i\bigcap\alpha_j|}$, that is $Q^2 = nI_n$. There existed a lower triangular matrix $L$ built by $\Omega$ satisfying $A=LQ$. In this report, we build matrix $A$ and show
$L = AQ^{-1}$ is a lower triangular matrix.

With matrix $A$ shown above, matrix $Q$ and $L$ is shown below:
$$Q=
\left[\begin{smallmatrix}
    1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &  \\
    1 & -1 & 1 & 1 & 1 & -1 & -1 & -1 & 1 & 1 & 1 & -1 & -1 & -1 & 1 & -1 \\
    1 & 1 & -1 & 1 & 1 & 1 & 1 & -1 & -1 & -1 & 1 & 1 & -1 & -1 & -1 & -1 \\
    1 & 1 & 1 & -1 & 1 & 1 & -1 & 1 & 1 & -1 & -1 & -1 & -1 & 1 & -1 & -1 \\
    1 & 1 & 1 & 1 & -1 & -1 & 1 & 1 & -1 & 1 & -1 & -1 & 1 & -1 & -1 & -1 \\
    1 & -1 & 1 & 1 & -1 & 1 & -1 & -1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 & 1 \\
    1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\
    1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 & 1 \\
    1 & 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 & 1 \\
    1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 & 1 \\
    1 & 1 & 1 & -1 & -1 & -1 & -1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 & 1 \\
    1 & -1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 & -1 & 1 & -1 & 1 & 1 & 1 & -1 \\
    1 & -1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 & 1 & -1 & 1 & -1 & 1 & 1 & -1 \\
    1 & -1 & -1 & 1 & -1 & 1 & -1 & 1 & 1 & -1 & -1 & 1 & 1 & -1 & 1 & -1 \\
    1 & 1 & -1 & -1 & -1 & -1 & -1 & -1 & 1 & 1 & 1 & 1 & 1 & 1 & -1 & -1 \\
    1 & -1 & -1 & -1 & -1 & 1 & 1 & 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 & 1 \\
\end{smallmatrix}\right],
$$

$$Q\times Q = 
\left[\begin{smallmatrix}
    16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 16&  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16&  0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 16 \\
\end{smallmatrix}\right],
$$

$$L=
\left[\begin{smallmatrix}
    1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.5 & 0.5 & 0.0 & 0.0 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.0 & 0.5 & 0.5 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.5 & 0.5 & 0.0 & 0.0 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.5 & 0.0 & 0.0 & 0.5 & 0.0 & 0.0 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.0 & 0.5 & 0.5 & 0.0 & 0.0 & 0.0 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.5 & 0.0 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & -0.5 & 0.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.25 & 0.25 & 0.0 & 0.25 & 0.25 & 0.25 & 0.25 & 0.0 & 0.0 & 0.0 & -0.75 & 0.25 & 0.0 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.25 & 0.0 & 0.25 & 0.25 & 0.0 & 0.25 & 0.0 & 0.25 & 0.25 & -0.75 & 0.25 & 0.0 & 0.0 & 0.0 \\
    0.0 & 0.0 & 0.0 & 0.25 & 0.25 & 0.25 & 0.25 & 0.0 & 0.25 & 0.25 & 0.0 & 0.0 & -0.75 & 0.25 & 0.0 & 0.0 \\
    0.0 & 0.25 & 0.0 & 0.25 & 0.0 & 0.25 & 0.0 & 0.25 & 0.0 & 0.25 & 0.25 & 0.0 & 0.0 & -0.75 & 0.25 & 0.0 \\
    0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & 0.125 & -0.875 & 0.125\\
\end{smallmatrix}\right].
$$

%%%%%%%%%%%%%%%%%
%   2.3 Generate Matrix $B \in \mathcal{A}_{n - 1}^1$
%%%%%%%%%%%%%%%%%
\subsection{Mapping Matrix $A \in \mathcal{A}_n^2$ to $B \in \mathcal{A}_{n - 1}^1$}
With matrix $A \in \mathcal{A}_n^2$, $\chi(A)=2^{\frac{1}{2}n\log n-n(1+o(1))}$ being constructed, a mapping can be implemented to generate a matrix $A \in \mathcal{A}_{n-1}^{1}$ such that $\chi(B)=2^{\frac{1}{2}n\log n-n(1+o(1))}$. Consider the map $\Phi$ which assigns to any matrix $B \in \mathcal{A}_{n - 1}^1$ a matrix $\Phi(B) \in \mathcal{A}_{n}^2$ in the following way:
$$ \Phi(B) = \left(\begin{array}{cc} 
1 & 1_{n-1}\\
-1^T_{n-1} & 2B-J_{n-1}
\end{array}\right).
$$

We can see that $\Phi(B)$ is a mapping $\mathcal{A}_n^2 \to \mathcal{A}_{n - 1}^1$ with a series of linear operations. Therefore, we have the following reversing way to construct matrix $B \in \mathcal{A}_{n - 1}^1$ with $A=\{a_{ij}\}\in \mathcal{A}_n^2$:

$$B = \frac{1}{2}(J_{n-1}+\{a_{ij}\}_{2\le i\le n, 2\le j\le n}).$$

Notice that in the above section, the $A \in \mathcal{A}_n^2$ we constructed has it's first column as:
$$ \left(\begin{array}{cc} 
1\\
1^T_{n-1}
\end{array}\right),
$$
so we need to negative the first column, and have the relation between matrix $B \in \mathcal{A}_{n - 1}^1$ and $A \in \mathcal{A}_n^2$ in the implementation shown as follows:    
$$B = \frac{1}{2}(J_{n-1}-\{a_{ij}\}_{2\le i\le n, 2\le j\le n}).$$

With the matrix $A \in \mathcal{A}_n^2$ constructed above, a constructed matrix $B$ is shown below:

$$B=
\left[\begin{smallmatrix}
    1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 \\
    0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
    0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 1 & 1 \\
    0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\
    1 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 1 \\
    0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 1 \\
    0 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 1 \\
    0 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\
    0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
    1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
    0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 0 \\
    0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 \\
    0 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 \\
    1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
\end{smallmatrix}\right].
$$

Shown in \cite{ALON1997133}, matrix $B$ preserves the ill-conditions property, that is $\chi(B)=2^{\frac{1}{2}n\log n-n(1+o(1))}$.

%%%%%%%%%%%%%%%%%
%   2.4 Generate and Verify Ill-conditioned Matrix $C$
%%%%%%%%%%%%%%%%%
\subsection{Generate and Verify Ill-conditioned Matrix $C$}
Before constructing matrix $C$, \cite{ALON1997133} shows a way concatenating that has a special property. Let $S$ and $T$ be two non-singular matrices of order $n_1$ and $n_2$. Define $S \diamond T$ as follows:
$$R=
\left[\begin{smallmatrix}
    s_{11} & \dots & s_{1n_1} & 0 & \dots  & 0 \\
    s_{21} & \dots & s_{2n_1} & 0 & \dots  & 0 \\
    \vdots & \vdots & \vdots & \vdots & \vdots \\
    s_{n_11} & \dots & s_{n_1n_1} & 0 & \dots  & 0 \\
    0 & 0 \dots 0 & 1 & t_{11} & \dots & t_{1n_2} \\
    0 & 0 \dots 0 & 0 & t_{21} & \dots & t_{2n_2} \\
    \vdots & \vdots & \vdots & \vdots & \vdots \\
    0 & 0 \dots 0 & 0 & t_{n_21} & \dots & t_{n_2n_2} \\
\end{smallmatrix}\right].
$$

It's shown that $R$ has the following property:

\begin{align*}
\chi(S \diamond T) \geq \chi(S)\chi(S),
\end{align*}

Which shows an increased $condition\ number$ leading to construct the ill-conditioned $C$. Consider the $(0, 1)$ matrix $C = A_1 \diamond (A_2 \diamond (. . . (A_{r-1} \diamond A_r))...)$ with order $\sum_{i=1}^rn_i=n$, with the definition of the operator $\diamond$, we have the following conclusion that
$$\chi(C)\geq \prod_{i=1}^r\chi(A_i) > 2^{\frac{1}{2}n\log n-n(2+o(1))}$$
This conclusion describes the lower bound of $\chi(C)$, and we can say matrix $C$ is ill-conditioned with respect to $n$.

Since the concatenation rapidly enlarge the order of the matrix, we could not show the matrix $C$ constructed with all the steps described in pervious sections. Instead, we show some result of $\chi(C)$ with $C$ generate in the same steps above. Remind that $C = A_1 \diamond (A_2 \diamond (. . . (A_{r-1} \diamond A_r))...)$, where $r$ is the biggest order of all the $\{0, 1\}$ matrices $A$:

\begin{lstlisting}[escapeinside={(*}{*)}]
r = 2, order of C = 4, (*$\chi$*)(C) = 1.0
r = 3, order of C = 11, (*$\chi$*)(C) = 2.0
r = 4, order of C = 26, (*$\chi$*)(C) = 260.0
r = 5, order of C = 57, (*$\chi$*)(C) = 106491641548.6
\end{lstlisting}

With the result above, We can clearly observe that as order $r$ grows, $\chi(C)$ may grow rapidly to infinity.

%%%%%%%%%%%%%%%%%
%   3 Complexity of Generating Matrix $C$
%%%%%%%%%%%%%%%%%
\section{Complexity Analysis of Generating Matrix $C$}
\subsection{Time Complexity of Creating $\Omega$}
In this section we discuss the complexity of constructing matrix $C$, and further more show the reason not being able to generate matrix $C$ with large $r$. Since we go through all these steps with code, we assume that we have enough memory and focus on the time complexity.

In order to generate set $\Omega$, everytime we only need to take out one generated set and insert one new element inside. The insertion operation is $O(\log n)$, but notice that we always insert an element greater than the maximum of a set, we can consider it an $O(1)$, without considering the maintenance of the internal tree data structure. Therefore, the most ideally time complexity is $O(n)$, which cannot be reach but will be used.

A more detailed complexity analysis is shown below. In the implementation, there are 2 for-loop with $O(m)$ and at least $O(m)$ time complexity. With all the assignment, set insertion, set reversion operation and an extra for-loop are neglected, a rough time complexity estimation would be $O(m^2)$.

\begin{algorithm}[H] 
    \caption{Time Complexity of Generating $\Omega$}
    \label{alg:loop_tc}
    \begin{algorithmic}[1]
    \Require{$m$} 
    \Ensure{$\Omega$}
      \State {$\Omega$ $\gets$ $\{\{\}, \{\}, \{1\}, \{2\}, ..., \{m\}\}$}
        \For{$i \gets 1$ to $m-1$} \Comment{$O(m)$ loop}
            \State {$\Phi$ $\gets$ $sets\ in\ \Omega\ with\ size\ equals\ i$} \Comment{$O(1)$ with special data structure}         
            \For{$\phi$ in $\Phi$} \Comment{${m \choose i} \rightarrow$ at least $O(m)$}
                \State {$\alpha$ $\gets$ [max($\phi$) + 1, ..., m]} \Comment{the max(...) of an ordered set is $O(1)$}
                \If{$\alpha$ not in $\Omega$[-1]}:
                    \State {$\alpha$ $\gets$ $\alpha$.reverse()} \Comment{a set reversion operation}
                \EndIf
                \For{$a$ in $\alpha$} \Comment{$m - $max$(\phi) - 1$, more than $O(1)$}
                    \State {$\Omega$ $\gets$ \{$\Omega$..., \{$\phi$..., $a$\}\}} \Comment{a set insertion operation}
                \EndFor
            \EndFor
        \EndFor
        \State \Return {$\Omega$}
    \end{algorithmic}
\end{algorithm}

\subsection{Time Complexity of Creating $\{0, 1\}$ Matrix $C$}
To generate every entry of matrix $A \in \mathcal{A}_n^2$, visits of all elements in $A$ is necessary. Let $m$ stands for the size of set  $\Omega$, $n=2^m$ be the order of matrix $A$, without considering the complexity of set indexing, the union operation and the intersection operation needed in every single calculation, the ideally time complexity of construct a matrix $A \in \mathcal{A}_n^2$ is at least $O(m) + O(2^{2m}) = O(2^m)$.

Generating matrix $B\in \mathcal{A}_{n - 1}^1$ required simple matrix operation. Let $n - 1$ be the order of $B$, the time complexity of this part is $O((n-1)^2) = O(n^2) = O(2^m)$.

To splice out matrix $C$, we need a series of matrix $A_1$, $A_2$, ... , $A_n$ with orders $2^1-1, 2^2-1, ..., 2^m-1$. With matrix $A_r$ with order $r$ having $O(r^2)$ time complexity, to create all these matrices, we can estimate a sum up, that is $\sum_{i=1}^{m}O((2^m - 1)^2) = O(m2^{2m}) = O(m2^m) = O(2^m)$. An extra time complexity of matrix assignment is also needed, which is ($\sum_{i=0}^{m}O(2^m - 1))^2 = O(m^22^{2m})$ or $O(2^m)$

Remind that we only consider parts of the essential operation, most of the internal operation including indexing, union, intersection and more. Therefore, to create the $\{0, 1\}$ Matrix $C$, we need an exponential time complexity; when $m$ grows, the time required to generate matrix $C$ grows exponentially.

The following figure \ref{costoftime} shows the relation between time of generating matrix $C$ and size controller $m$. An exponential growth is shown as expected.

\begin{figure}[htp]
    \centering
    \includegraphics{fig/output.png}
    \caption{Cost of time in milliseconds related to m}\label{costoftime}
\end{figure}

%%%%%%%%%%%%%%%%%
%   4 Conclusion   %
%%%%%%%%%%%%%%%%%
\section{Conclusion}
This report shows the $\{0, 1\}$ matrix $C$ created with speacific steps to ensure it's equivalent condition number $\chi(C) > 2^{\frac{1}{2}n\log n-n(2+o(1))}$ is ill-conditioned as it's order grows. Also, we prove the exponential time complexity of creating such a matrix, showing that it's is expensive to create when the order of $C$ grows.

%%%%%%%%%%%%%%%%%
%   5 Acknowledgements   %
%%%%%%%%%%%%%%%%%
\section{Acknowledgements}
I would like to thank Antoine Deza, my supervisor, for many helpful discussions and advice. Also I would like to thank Zhongyuan Liu and Yijun Ma for many helpful suggestions.

\newpage
%%%%%%%%%%%%%%%%%%%%
%   6 References   %
%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{references}


\newpage
\appendix
\subsection*{Code of Implementation}
\adjincludegraphics[width=15cm,trim={0 {.763\height} 0 0},clip]{fig/codeofimp.png}\\
\adjincludegraphics[width=15cm,trim={0 {.504\height} 0 {.237\height}},clip]{fig/codeofimp.png}\\
\adjincludegraphics[width=15cm,trim={0 {.245\height} 0 {.496\height}},clip]{fig/codeofimp.png}\\
\adjincludegraphics[width=15cm,trim={0 {.0\height} 0 {.755\height}},clip]{fig/codeofimp.png}\\

\end{document}